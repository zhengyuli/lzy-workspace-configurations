;;; template-autoloads.el --- automatically extracted autoloads
;;
;;; Code:


;;;### (autoloads nil "template" "template.el" (21775 62778 0 0))
;;; Generated autoloads from template.el

(autoload 'template-single-comment "template" "\
Decorate the comment in the current line with dashes and alike.
The line must be a comment-only line or must contain a comment ending by
eol.  That is, jump to the end of the current line and insert the dashes
and the final comment end-string up-to the fill position.  Prefix
argument ARG and `template-comment-specification' determines the comment
style to use.  The length of the resulting line is determined by
`template-max-column' and `template-max-column-with-end'.

\(fn &optional ARG)" t nil)

(autoload 'template-block-comment "template" "\
Decorate the current block of comment-only lines with dashes and alike.
That is, surround the the contiguous comment-only lines around point
with extra lines containing dashes and alike and to put the correct
number of newlines around the block.

Barf if the comment syntax at point has a non-empty `comment-end' or if
point is not in a comment-only line.

A block comment consists of all neighboring lines which start with
spaces and `comment-start'.  If `comment-start' is a string of length 1,
the number of repetitions of `comment-start' must be the same or larger
than in the line where the command is invoked from, too.

Prefix argument ARG and `template-comment-specification' determines the
comment style to use.  The length of the separator line is determined by
`template-max-column'.

This command can also be used with point in an empty line after a block
comment.  A second invocation of this command directly after a
successful invocation deletes the remaining empty lines from the current
line on.

\(fn &optional ARG)" t nil)

(autoload 'template-update-header "template" "\
Replace old file name in header with current file name.
If SHOW is t, just return region of the filename or nil.  Otherwise,
replace filename if possible and signal an error if SHOW is nil and
there is no filename in the header.  See `template-header-lines' and
`template-header-regexp-alist'.

\(fn &optional SHOW)" t nil)

(autoload 'template-expand-template "template" "\
Expand template file TEMPLATE and insert result in current buffer.
Using a template for inserting some text consists of:
  1. Template derivation: suggest a reasonable template file to the user
     according to `buffer-file-name', see `template-derivation-alist'.
  2. Template insertion: insert the template file at point into the
     current buffer.
  3.. as steps 6.. of `template-new-file'.

\(fn TEMPLATE)" t nil)

(autoload 'template-new-file "template" "\
Open a new file FILE by using a TEMPLATE.
Using a template for creating a new file consists of, steps 1 to 3 are
only executed when called interactively:
  1. Prompt for the name of the new file.
  2. Template derivation: suggest a reasonable template file to the user
     see `template-derivation-alist'.
  3. File name refinement: e.g., if the given file name is \"exercise\"
     and there are two files \"exercise1.tex\" and \"exercise2.tex\" in
     the same directory and if we have a template \"exercise.tex.tpl\",
     the file name is refined to \"exercise3.tex\".  This is turned off
     when \\[template-new-file] is called with a prefix argument.
  4. Template insertion: insert the template file into the empty buffer.
  5. Read per-template expansion definition section starting at
     `template-definition-start' and delete it.
  6. Display :before message in `template-message-buffer'.
  7. Execute pre-expansion commands defined in the definition section.
  8. Set local variables defined in the definition section.
  9. Ask user for strings to insert for prompts to be executed
     immediately, see `template-definition-start'.
 10. Expansion: expand the expansion forms (text matched by
     `template-expansion-regexp') They are defined in the definition
     section, in `template-expansion-alist', or provided by default, see
     `template-expansion-regexp' and `template-register-regexp'.
 11. Execute post-expansion commands defined in the definition section.
 12. Run `normal-mode' and functions in `find-file-hooks'.
 13. Update header according to `template-update-header' with argument
    `if-exists'.
 14. Display :after message in `template-message-buffer'.
 15. Report: display a temporary message at point defined in the
     definition section and an automatically generated message in the
     minibuffer area, see `template-message-timeout'.

If optional WITH-UNDO is non-nil, store corresponding changes in
`buffer-undo-list'.  If FILE is nil, the buffer for FILE has already
been created and the accessible part will be replaced by the expanded
template.  If TEMPLATE is nil (empty input when called interactively),
do not use a template.

\(fn FILE TEMPLATE &optional WITH-UNDO)" t nil)

(autoload 'template-initialize-do "template" "\
Initialized package template.  See variable `template-initialize'.

\(fn)" nil nil)

(autoload 'template-initialize "template" "\
Compatibility command to enable package template.

\(fn &rest DUMMIES)" t nil)

;;;***

(provide 'template-autoloads)
;; Local Variables:
;; version-control: never
;; no-byte-compile: t
;; no-update-autoloads: t
;; coding: utf-8
;; End:
;;; template-autoloads.el ends here
